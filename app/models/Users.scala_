package models

import java.sql.Timestamp
import java.util.Date
import org.joda.time.DateTime
import securesocial.core._
import scala.language.implicitConversions
import slick.driver.JdbcProfile
import slick.driver.MySQLDriver.api._
import slick.lifted.ProvenShape


import securesocial.core.providers.MailToken

case class User(
  identityId: String,
  firstName: String,
  lastName: String,
  fullName: String,
  email: Option[String],
  avatarUrl: Option[String],
  authMethod: AuthenticationMethod,
  oAuth1Info: Option[OAuth1Info],
  oAuth2Info: Option[OAuth2Info],
  passwordInfo: Option[PasswordInfo] = None,
  providerId: String = "userpass",
  uid: Option[Long] = None
)
  case class UserRow(id: Long, userId: String, providerId: String, firstName: String, lastName: String, fullName: String, email: Option[String] = None, avatarUrl: Option[String] = None, authMethod: String, token: Option[String] = None, secret: Option[String] = None, accessToken: Option[String] = None, tokenType: Option[String] = None, expiresIn: Option[Int] = None, refreshToken: Option[String] = None)

class Users(tag: Tag) extends Table[User](tag, "user") {

   implicit def javaDateMapper = MappedColumnType.base[Date, Timestamp](
      dt => new Timestamp(dt.getTime),
      ts => new Date(ts.getTime)
  )

  implicit def string2AuthenticationMethod =
    MappedColumnType.base[AuthenticationMethod, String] (
      authenticationMethod => authenticationMethod.method,
      string => AuthenticationMethod(string)
    )

  implicit def tuple2OAuth1Info(tuple: (Option[String], Option[String])): Option[OAuth1Info] = tuple match {
    case (Some(token), Some(secret)) => Some(OAuth1Info(token, secret))
    case _ => None
  }

  implicit def tuple2OAuth2Info(tuple: (Option[String], Option[String], Option[Int], Option[String])): Option[OAuth2Info] = tuple match {
    case (Some(token), tokenType, expiresIn, refreshToken) => Some(OAuth2Info(token, tokenType, expiresIn, refreshToken))
    case _ => None
  }

  def uid          = column[Long]("id", O.PrimaryKey, O.AutoInc)
  def userId       = column[String]("userId")
  def providerId   = column[String]("providerId")
  def email        = column[Option[String]]("email")
  def firstName    = column[String]("firstName")
  def lastName     = column[String]("lastName")
  def fullName     = column[String]("fullName")
  def authMethod   = column[AuthenticationMethod]("authMethod")
  def avatarUrl    = column[Option[String]]("avatarUrl")

  // oAuth 1
  def token        = column[Option[String]]("token")
  def secret       = column[Option[String]]("secret")

  // oAuth 2
  def accessToken  = column[Option[String]]("accessToken")
  def tokenType    = column[Option[String]]("tokenType")
  def expiresIn    = column[Option[Int]]("expiresIn")
  def refreshToken = column[Option[String]]("refreshToken")

  def * : ProvenShape[User] = {
    val shapedValue = (uid.?,
      userId,
      providerId,
      firstName,
      lastName,
      fullName,
      email,
      avatarUrl,
      authMethod,
      token,
      secret,
      accessToken,
      tokenType,
      expiresIn,
      refreshToken).shaped

    shapedValue.<>({
      tuple =>
        User(
          uid = tuple._1,
          identityId = tuple._2,
          firstName = tuple._4,
          lastName = tuple._5,
          fullName = tuple._6,
          email = tuple._7,
          avatarUrl = tuple._8,
          authMethod = tuple._9,
          oAuth1Info = (tuple._10, tuple._11),
          oAuth2Info = (tuple._12, tuple._13, tuple._14, tuple._15)
    )}, {
      (u: User) =>
        Some {(
            u.uid,
            u.identityId,
            u.providerId,
            u.firstName,
            u.lastName,
            u.fullName,
            u.email,
            u.avatarUrl,
            u.authMethod,
            u.oAuth1Info.map(_.token),
            u.oAuth1Info.map(_.secret),
            u.oAuth2Info.map(_.accessToken),
            u.oAuth2Info.flatMap(_.tokenType),
            u.oAuth2Info.flatMap(_.expiresIn),
            u.oAuth2Info.flatMap(_.refreshToken)
        )}
    })
  }
}

import securesocial.core.providers.MailToken

class MailTokens(tag: Tag) extends Table[MailToken](tag, "token") {
  
  def uuid = column[String]("uuid")
  def email = column[String]("email")
  def creationTime: Rep[DateTime] = column[DateTime]("creationTime", O.Default(0))
  def expirationTime: Rep[DateTime] = column[DateTime]("expirationTime", O.Default(0))
  def isSignUp = column[Boolean]("isSignUp")

  def * : ProvenShape[MailToken] = {
    val shapedValue = (uuid, email, creationTime, expirationTime, isSignUp).shaped
    shapedValue.<>({
      tuple =>
        MailToken(uuid = tuple._1,
          email = tuple._2,
          creationTime = tuple._3,
          expirationTime = tuple._4,
          isSignUp = tuple._5)
    }, {
      (t: MailToken) =>
        Some {
          (t.uuid,
            t.email,
            t.creationTime,
            t.expirationTime,
            t.isSignUp)
        }
    })
  }
}


